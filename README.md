# Interview-Prepare
Record something which are benifit to the interview

## Netty 一个基于 Java NIO 的高性能开发框架。

* Java 网络编程的历史
说到 NIO，就离不开网络编程。传统的 Java 网络编程是基于同步阻塞的 BIO 流进行 socket 编程，这样种方式有一个优点就是编程简单，
但同样缺点也很明显：对于每个一个客户端的请求都需要创建一条线程去处理 IO 任务。每一条线程本身就会占用一定的 JVM 内存资源，并且在线程数量超过一定阈值后，
由于频繁的上下文切换，性能不升反降。此乃第一个阶段。

对于处理创建过多线程这个问题，其解决方式都是大同小异的，那就是应用“池”的模式（类比）。
一个池，它维护了一个任务队列和指定数量的若干个活跃线程，当服务端接受到客户端的请求时，将该请求封装成一个任务（实现 Runnable 接口）放入池中的任务队列，
由池中的线程进行轮流消费。这样限定处理线程的数量，就解决了当客户端请求大幅增长时，服务器里宕机的风险。这种模式对于“每个请求对应一条线程”而言，
的确是一种改良，它被称为“伪异步 IO”。此乃第二个阶段
那么它存在什么问题呢，看上去不是挺优秀的？
设想下，当客户端网络较差或者发送的数据量较大时，服务端读取时是处于较长时间的阻塞状态；同样，当客户端网络条件较差时，从 TCP 缓冲区取数据缓慢，
导致一段时间后缓冲区被占满，服务端将会在写出时阻塞。此时任务队列中任务会越积越多，直到无法接受任务，此时，客户端将发生连接超时...

直到... NIO 的出现。

在 BIO 的套接字（socket）编程中，有两个产生 socket 的类，它们分别是 “Socket” 和 “ServerSocket”，
在 NIO 中，提供了 “SocketChannel” 和 “ServerSocketChannel” 两种不同的套接字实现。这两种通道同时支持阻塞和非阻塞模式。

BIO 面向流（Stream）编程，在 NIO 中是面向缓冲区（Buffer）的。
除了 boolean 类型，其余所有 Java 基本数据类型都对应着一个缓冲区，ByteBuffer，IntBuffer，LongBuffer等。

    


